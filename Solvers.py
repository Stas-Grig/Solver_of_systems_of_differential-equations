from numpy import zeros, linspace, matmul, eye, linalg

def solver(f, y_t0, t_0, T, M_0, r, s, method, *, f_y):

    order = len(y_t0) # Определение порядка системы дифференциальных уравнений

    M = M_0 * r ** s # Сгущение сетки с заданным множителем r и текущим номером сгущения s

    y_basic = zeros((M_0 + 1, order)) # Выделение места в памяти для контрольных точек, участвующих в оценки ошибки

    t = linspace(t_0, T, M + 1) # Разбиение интервала времени на сеточные значения

    tau = (T - t_0) / M # Определение шага по времени

    y = zeros((M + 1, order)) # Выделение места в памяти для сеточных значений искомых функций

    y[0] = y_t0 # Задаются начальные условия при t = t_0

    # Метод Рунге - Кутты первого порядка
    if method == "ERK1":
        for m in range(M):
            y[m + 1] = y[m] + tau * f(y[m], t[m]) # Вычисление сеточных значений искомых функций

    # Метод Рунге - Кутты второго порядка
    if method == "ERK2":
        for m in range(M):
            w_1 = f(y[m], t[m])
            w_2 = f(y[m] + tau * 2 / 3 * w_1, t[m] + 2 / 3 * tau)

            y[m + 1] = y[m] + tau * (1 / 4 * w_1 + 3 / 4 * w_2) # Вычисление сеточных значений искомых функций

    # Метод Рунге - Кутты четвертого порядка
    if method == "ERK4":
        for m in range(M):
            w_1 = f(y[m], t[m])
            w_2 = f(y[m] + tau * 1 / 2 * w_1, t[m] + 1 / 2 * tau)
            w_3 = f(y[m] + tau * 1 / 2 * w_2, t[m] + 1 / 2 * tau)
            w_4 = f(y[m] + tau * w_3, t[m] + tau)

            y[m + 1] = y[m] + tau * (w_1 + 2 * w_2 + 2 * w_3 + w_4) / 6 # Вычисление сеточных значений искомых функций

    # Метод Розенброка с комплексным коэффициентом для решения жестких задач, L2 устойчивость
    if method == "CROS1":
        for m in range(M):
            alpha = (1 + 1j) / 2
            D = linalg.inv(eye(order) - alpha * tau * f_y(y[m], t[m]))
            w_1 = matmul(D, f(y[m], t[m] + tau * 1 / 2))

            y[m + 1] = y[m] + tau * w_1.real # Вычисление сеточных значений искомых функций

    for m in range(M_0):
        y_basic[m] = y[m * r ** s] # Вычисление сеточных значений искомых функций в контрольных точках (дальнейшее вычисление ошибки)

    """Функция возвращает значение искомых функций и их значения в контрольных точках, также она возвращает сеточные 
    значения по оси времени для дальнейшей работы с ними и количество точек разбиения """

    return (y_basic, y, t, M)




